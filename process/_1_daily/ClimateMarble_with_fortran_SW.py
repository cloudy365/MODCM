

# Date: 2018.05.16 -- tidy up the script
# This should be the final (?) productive code for MODIS Climate Marble project.
# Date: 2018.05.23 -- generalize FORTRAN code accounting for different SPATIAL resolution.
# Date: 2018.05.29 -- keep debugging, sum_num in band 6 shows wired float number along idx_lon=7199.
# The problem has been found related to the longitude = 180.0 and solved by adding lons_idx>=0.
# The previously occasional crash is found to be related to the outputs of latslons_to_idxs function, which should be converted to integer before passing to fortran.
# Date: 2018.06.01 -- change function name 'main' to 'main_daily'. 


from my_module import os, h5py, np, sys, tqdm
from my_module.data.comm import save_data_hdf5
from helper_func import latslons_to_idxs
from sample2grid_sw import sort
import time



# Parameters (need to set)
# Spatial resolution, number of channels, and maximum VZA
SPATIAL_RESOLUTION = 0.05        
NUM_CHAN = 7 # 7
VZA_MAX = 40


# Automatically calculated
NUM_POINTS = 1 / SPATIAL_RESOLUTION
NUM_LATS = int(180 / SPATIAL_RESOLUTION)
NUM_LONS = int(360 / SPATIAL_RESOLUTION)



def main_daily(mod02, mod03, output_folder):
    """
    Specify the {paths} of MOD021KM_XX_daily and MOD03_daily data as well as the output path.
    
    e.g.,   
    mod02 = '/path/to/data/MOD021KM.A2000168.006.h5'  
    mod03 = '/path/to/data/MOD021KM.A2000168.006.h5'  
    output_folder = '/u/sciteam/smzyz'

    The output will be A2000168.h5 stored under output_folder.
    This code supports VIS bands for now and will be updated for other bands later (if necessary).
    """
    

# =============================================================================
# 1. Initialize 
#    1) MOD02/03 data interfaces
#    2) output arrays
# =============================================================================
    mod_date = mod03.split('.')[1]
    try:
        mod02 = h5py.File(mod02, 'r')
        mod03 = h5py.File(mod03, 'r')
    except IOError:
        print ">> IOError, cannot access {}".format(mod_date)
        return

    # Initialize output arrays and output hdf5 file
    daily_insolation_sum = np.zeros((NUM_LATS, NUM_LONS, NUM_CHAN))
    daily_radiance_sum = np.zeros((NUM_LATS, NUM_LONS, NUM_CHAN))
    daily_radiance_num = np.zeros((NUM_LATS, NUM_LONS, NUM_CHAN), dtype='int16')
    daily_h5f_out = os.path.join(output_folder, '{}.h5'.format(mod_date))


# =============================================================================
# 2. Obtain output arrays
#    Loop through each MODIS granule and sort the radiances into the corresponding lat/lon bins.
#    Times are generated by times_gen function, for 24 * 12 (60/5) intervals.
#    When encounters a missing granule, script will raise a KeyError and move to the next granule.
# =============================================================================
    #times = times_gen(2)[:]
    #for i in tqdm(range(len(times))):
    #     itime = times[i]
    
    times = [str(i[0]) for i in mod02.items()]
    for itime in tqdm(times):
        
        
        
        
        
        # =============================================================================
        # 2.1 lat/lon check
        #     lats, lons, lats_idx, lons_idx will be used in the main fortran subroutine
        # =============================================================================
        try:
            lats = mod03['{}/Latitude'.format(itime)][:]
            lons = mod03['{}/Longitude'.format(itime)][:]
        except KeyError:
            print ">> KeyError, cannot access lat/lon in {}.{}".format(mod_date, itime)
            continue
        
        # SAMPLE-LEVEL CHECK is applied here
        # Process descending granules only (neutral granules are omitted)
        cnt = 0
        for i in range(1, len(lats)):
            if all(lats[i]<lats[i-1]) == False:
                cnt += 1
        if cnt >= 1000:
            continue
            
        # Calculate lat/lon indexes of all sample
        # (2018.05.29) Explicitly convert these indexes to integer
        lats_idx, lons_idx = latslons_to_idxs(lats, lons, NUM_POINTS)
        lats_idx = lats_idx.astype('int32')
        lons_idx = lons_idx.astype('int32')
        
        
        
        
        
        
        
        
        # =============================================================================
        # 2.2 sza/vza check
        #     sza, vza, valid_y, valid_x, valid_num will be used in the main fortran subroutine
        # =============================================================================
        try:
            sza = mod03['{}/SolarZenith'.format(itime)][:, :]/100.
            vza = mod03['{}/SensorZenith'.format(itime)][:, :]/100.
        except KeyError:
            print ">> KeyError, cannot access sza/vza in {}.{}".format(mod_date, itime)
            continue
        
        # SAMPLE-LEVEL CHECK is applied here
        # 0 <= SZA <= 89.0  and  0 <= VZA < 40.0 and longitude_indexes >= 0     
        # Get valid_num, valid_x, valid_y
        valid_y, valid_x = np.where((sza>=0)&(sza<=89.0)&(vza>=0)&(vza<VZA_MAX)&(lons_idx>=0))
        valid_num = len(valid_x)
        if valid_num == 0:
            continue
        
        
        
        
        
        
        
        
        
        # =============================================================================
        # 2.3 radiance check
        # Since most (not all) bands' (1--7) 65528 suggest saturation, Larry and I decided
        # to replace all 65528 values with spectral maximum radiance.
        #
        # Because 65528 is actually Aggregation Algorithm Failure that not only caused by
        # the signal saturation, red band is used to illustrate whether the sample is actually
        # saturated (red_band != 65528) or is caused by any other issues (red_band == 65528).
        #
        # Note that:
        # 1) Saturated samples in other bands are refilled only when red_band != 65528.
        # 2) Red band samples are never refilled.
        # 3) This approach is only applied to VIS category (not for SWIR and LW categories).
        # =============================================================================
        mdata = mod02['{}/Scaled_Integers'.format(itime)][:]
        rad_scales = mod02['{}/Radiance_Scales'.format(itime)][:]
        rad_offset = mod02['{}/Radiance_Offsets'.format(itime)][:]
        ref_scales = mod02['{}/Reflectance_Scales'.format(itime)][:]
        ref_offset = mod02['{}/Reflectance_Offsets'.format(itime)][:]
        coeffs = rad_scales / ref_scales
        cosine_sza = np.cos(np.deg2rad(sza))
        
        # Calculate spectral radiances and insolation using:
        #          reflected_radiance = (scaled_integer - rad_offset) * rad_scale
        #          insolation = cos(sza) * rad_scale / ref_scale
        #          reflected_radiance_max = (32767 - rad_offset) * rad_scale
        sols = []
        rads = []
        rads_max = []
        for iband in range(NUM_CHAN):
            tmp_sol = cosine_sza * coeffs[iband]

            tmp_mdata = mdata[iband]
            tmp_rad = (tmp_mdata - rad_offset[iband]) * rad_scales[iband]
            tmp_rad_max = (32767 - rad_offset[iband]) * rad_scales[iband]

            # refill
            if iband > 0:
                refill_mask = (mdata[0]!=65528) & (tmp_mdata==65528)
                # print itime, iband, len(np.where(refill_mask.ravel()==True)[0])
                np.place(tmp_rad, refill_mask, tmp_rad_max)

            sols.append( tmp_sol )
            rads.append( tmp_rad )
            rads_max.append( tmp_rad_max )
        
        sols = np.array(sols)
        rads = np.array(rads)
        sols = np.rollaxis(sols, 0, 3)
        rads = np.rollaxis(rads, 0, 3)
        rads_max = np.array(rads_max)
        
        
        
        
        
        
        
        
        # =============================================================================
        # 2.4 Call main fortran subroutine to sort granule samples into lat/lon grids
        #
        # Get daily_insolation_sum, daily_radiance_sum, daily_radiance_num
        # valid lat/lon   (lat != -999 and lon != -999 and idx_lat/lon are valid)
        # valid radiance  (0 < rad <= rad_max)
        # =============================================================================
        daily_insolation_sum, daily_radiance_sum, daily_radiance_num = sort(NUM_CHAN, NUM_LATS, NUM_LONS, \
            valid_num, valid_x, valid_y, \
            len(lats_idx), lats, lons, lats_idx, lons_idx, \
            rads, sols, rads_max, \
            daily_insolation_sum, daily_radiance_sum, daily_radiance_num)
        
        

# =============================================================================
# 3. Check output arrays
# =============================================================================
#     daily_mean_radiance = []
#     daily_mean_insolation = []
#     for iband in range(NUM_CHAN):
#         tmp_num = daily_radiance_num[:, :, iband]
#         tmp_rad = daily_radiance_sum[:, :, iband] / tmp_num    # np.nan arises when 0.0/0.0
#         tmp_sol = daily_insolation_sum[:, :, iband] / tmp_num
        
#         np.place(tmp_rad, tmp_num>100., 0)
#         np.place(tmp_sol, tmp_num>100., 0)
#         daily_mean_radiance.append(np.nan_to_num(tmp_rad))
#         daily_mean_insolation.append(np.nan_to_num(tmp_sol))






# =============================================================================
# 4. Save output arrays
# =============================================================================
    save_data_hdf5(daily_h5f_out, '/radiance_sum', daily_radiance_sum)
    save_data_hdf5(daily_h5f_out, '/radiance_num', daily_radiance_num)
    save_data_hdf5(daily_h5f_out, '/insolation_sum', daily_insolation_sum)
    mod02.close()
    mod03.close()

    

    
    
    
    

def times_gen(itype):
    """
    Generate times for processing, itype could be 1 or 2.
    itype == 1: Generate iyr+iday for MPI processing;
    itype == 2: Generate ihr+imin for granule processing, which calls once at the very begining of the Main function.
    """
    times = []
    if itype == 1:
        for iyr in range(2000, 2016):
            for iday in range(1, 367):
                tmp = "{}{}".format(iyr, str(iday).zfill(3))
                times.append(tmp)
                
    elif itype == 2:
        for ihr in range(0, 24):
            for imin in range(0, 60, 5):
                tmp = "{}{}".format(str(ihr).zfill(2), str(imin).zfill(2))
                times.append(tmp)

    return np.array(times)







    
    
if __name__ == '__main__':

    if sys.argv[1] == 'test':
        # Single_file test -- checked on 2018.05.07.
        # Turn on tqdm
        mod03 = '/u/sciteam/smzyz/scratch/data/MODIS/MOD03_daily/2000/MOD03.A2000056.006.h5'
        mod02 = '/u/sciteam/smzyz/scratch/data/MODIS/MOD02_VIS_daily/2000/MOD021KM.A2000056.006.h5'
        output_folder = '/u/sciteam/smzyz/'
        main_daily(mod02, mod03, output_folder)
    
    elif sys.argv[1] == 'batch':
        # Batch_job test -- checked on 2018.05.07.
        # Turn off tqdm
        NUM_CORES = int(sys.argv[2])


        import mpi4py.MPI as MPI
        comm = MPI.COMM_WORLD
        comm_rank = comm.Get_rank()



        output_folder = '/u/sciteam/smzyz/scratch/results/MODIS_ClimateMarble_005deg/daily/vis'
        
        times = times_gen(1)[:]
        for idd in range(0, len(times), NUM_CORES):
            itime = times[idd+comm_rank]
            mod02_file = 'MOD021KM.A{}.006.h5'.format(itime)
            mod03_file = 'MOD03.A{}.006.h5'.format(itime)

            mod02_path = '/u/sciteam/smzyz/scratch/data/MODIS/MOD02_VIS_daily/{}/{}'.format(itime[:4], mod02_file)
            mod03_path = '/u/sciteam/smzyz/scratch/data/MODIS/MOD03_daily/{}/{}'.format(itime[:4], mod03_file)



            print ">> log: PE {} on {}".format(comm_rank, mod02_file)
            main_daily(mod02_path, mod03_path, output_folder)

