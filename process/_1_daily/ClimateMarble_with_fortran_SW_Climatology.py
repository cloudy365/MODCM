

# Date: 2018.06.01 -- copied and edited based on ClimateMarble_with_fortran_SW.py
# Main difference is that ClimateMarble_with_fortran_SW.py deals with single mod02, mod03 pair,and ClimateMarble_with_fortran_SW_Climatology.py deals with multiple pairs. time_gen function is modified accordantly.



from my_module import os, h5py, np, sys, tqdm
from my_module.data.comm import save_data_hdf5
from helper_func import latslons_to_idxs
from sample2grid_sw import sort
import time



# Parameters (need to set)
# Spatial resolution, number of channels, and maximum VZA
SPATIAL_RESOLUTION = 0.025           
NUM_CHAN = 7 # 7
VZA_MAX = 40


# Automatically calculated
NUM_POINTS = 1 / SPATIAL_RESOLUTION
NUM_LATS = int(180 / SPATIAL_RESOLUTION)
NUM_LONS = int(360 / SPATIAL_RESOLUTION)



def main_daily(mod02, mod03):
    """
    Specify the {paths} of MOD021KM_XX_daily and MOD03_daily data and return the gridded results.
    This code supports VIS bands for now and will be updated for other bands later (if necessary).
    
    e.g.,   
    mod02 = '/path/to/data/MOD021KM.A2000168.006.h5'  
    mod03 = '/path/to/data/MOD021KM.A2000168.006.h5'   
    """
    

# =============================================================================
# 1. Initialize 
#    1) MOD02/03 data interfaces
#    2) output arrays
# =============================================================================
    mod_date = mod03.split('.')[1]
    try:
        mod02 = h5py.File(mod02, 'r')
        mod03 = h5py.File(mod03, 'r')
    except IOError:
        print ">> IOError, cannot access {}".format(mod_date)
        return

    # Initialize output arrays and output hdf5 file
    daily_insolation_sum = np.zeros((NUM_LATS, NUM_LONS, NUM_CHAN))
    daily_radiance_sum = np.zeros((NUM_LATS, NUM_LONS, NUM_CHAN))
    daily_radiance_num = np.zeros((NUM_LATS, NUM_LONS, NUM_CHAN), dtype='int16')


# =============================================================================
# 2. Obtain output arrays
#    Loop through each MODIS granule and sort the radiances into the corresponding lat/lon bins.
#    Times are generated by times_gen function, for 24 * 12 (60/5) intervals.
#    When encounters a missing granule, script will raise a KeyError and move to the next granule.
# =============================================================================
    times = [str(i[0]) for i in mod02.items()]
    for itime in tqdm(times):
        
        # =============================================================================
        # 2.1 lat/lon check
        #     lats, lons, lats_idx, lons_idx will be used in the main fortran subroutine
        # =============================================================================
        try:
            lats = mod03['{}/Latitude'.format(itime)][:]
            lons = mod03['{}/Longitude'.format(itime)][:]
        except KeyError:
            print ">> KeyError, cannot access lat/lon in {}.{}".format(mod_date, itime)
            continue
        
        # SAMPLE-LEVEL CHECK is applied here
        # Process descending granules only (neutral granules are omitted)
        cnt = 0
        for i in range(1, len(lats)):
            if all(lats[i]<lats[i-1]) == False:
                cnt += 1
        if cnt >= 1000:
            continue
            
        # Calculate lat/lon indexes of all sample
        # (2018.05.29) Explicitly convert these indexes to integer
        lats_idx, lons_idx = latslons_to_idxs(lats, lons, NUM_POINTS)
        lats_idx = lats_idx.astype('int32')
        lons_idx = lons_idx.astype('int32')
        
        
        # =============================================================================
        # 2.2 sza/vza check
        #     sza, vza, valid_y, valid_x, valid_num will be used in the main fortran subroutine
        # =============================================================================
        try:
            sza = mod03['{}/SolarZenith'.format(itime)][:, :]/100.
            vza = mod03['{}/SensorZenith'.format(itime)][:, :]/100.
        except KeyError:
            print ">> KeyError, cannot access sza/vza in {}.{}".format(mod_date, itime)
            continue
        
        # SAMPLE-LEVEL CHECK is applied here
        # 0 <= SZA <= 89.0  and  0 <= VZA < 40.0 and longitude_indexes >= 0     
        # Get valid_num, valid_x, valid_y
        valid_y, valid_x = np.where((sza>=0)&(sza<=89.0)&(vza>=0)&(vza<VZA_MAX)&(lons_idx>=0))
        valid_num = len(valid_x)
        if valid_num == 0:
            continue
        
        
        # =============================================================================
        # 2.3 radiance check
        # Since most (not all) bands' (1--7) 65528 suggest saturation, Larry and I decided
        # to replace all 65528 values with spectral maximum radiance.
        #
        # Because 65528 is actually Aggregation Algorithm Failure that not only caused by
        # the signal saturation, red band is used to illustrate whether the sample is actually
        # saturated (red_band != 65528) or is caused by any other issues (red_band == 65528).
        #
        # Note that:
        # 1) Saturated samples in other bands are refilled only when red_band != 65528.
        # 2) Red band samples are never refilled.
        # 3) This approach is only applied to VIS category (not for SWIR and LW categories).
        # =============================================================================
        mdata = mod02['{}/Scaled_Integers'.format(itime)][:]
        rad_scales = mod02['{}/Radiance_Scales'.format(itime)][:]
        rad_offset = mod02['{}/Radiance_Offsets'.format(itime)][:]
        ref_scales = mod02['{}/Reflectance_Scales'.format(itime)][:]
        ref_offset = mod02['{}/Reflectance_Offsets'.format(itime)][:]
        coeffs = rad_scales / ref_scales
        cosine_sza = np.cos(np.deg2rad(sza))
        
        # Calculate spectral radiances and insolation using:
        #          reflected_radiance = (scaled_integer - rad_offset) * rad_scale
        #          insolation = cos(sza) * rad_scale / ref_scale
        #          reflected_radiance_max = (32767 - rad_offset) * rad_scale
        sols = []
        rads = []
        rads_max = []
        for iband in range(NUM_CHAN):
            tmp_sol = cosine_sza * coeffs[iband]

            tmp_mdata = mdata[iband]
            tmp_rad = (tmp_mdata - rad_offset[iband]) * rad_scales[iband]
            tmp_rad_max = (32767 - rad_offset[iband]) * rad_scales[iband]

            # refill
            if iband > 0:
                refill_mask = (mdata[0]!=65528) & (tmp_mdata==65528)
                np.place(tmp_rad, refill_mask, tmp_rad_max)

            sols.append( tmp_sol )
            rads.append( tmp_rad )
            rads_max.append( tmp_rad_max )
        
        sols = np.array(sols)
        rads = np.array(rads)
        sols = np.rollaxis(sols, 0, 3)
        rads = np.rollaxis(rads, 0, 3)
        rads_max = np.array(rads_max)
        
        
        # =============================================================================
        # 2.4 Call main fortran subroutine to sort granule samples into lat/lon grids
        #
        # Get daily_insolation_sum, daily_radiance_sum, daily_radiance_num
        # valid lat/lon   (lat != -999 and lon != -999 and idx_lat/lon are valid)
        # valid radiance  (0 < rad <= rad_max)
        # =============================================================================
        daily_insolation_sum, daily_radiance_sum, daily_radiance_num = sort(NUM_CHAN, NUM_LATS, NUM_LONS, \
            valid_num, valid_x, valid_y, \
            len(lats_idx), lats, lons, lats_idx, lons_idx, \
            rads, sols, rads_max, \
            daily_insolation_sum, daily_radiance_sum, daily_radiance_num)
       
    
    mod02.close()
    mod03.close()
    return daily_radiance_sum, daily_radiance_num, daily_insolation_sum





def main_daily_climatology(iday, output_folder='/u/sciteam/smzyz/'):
    
    str_iday = str(iday).zfill(3)
    
    
    # Initialize output arrays and output hdf5 file
    daily_insolation_sum = np.zeros((NUM_LATS, NUM_LONS, NUM_CHAN))
    daily_radiance_sum = np.zeros((NUM_LATS, NUM_LONS, NUM_CHAN))
    daily_radiance_num = np.zeros((NUM_LATS, NUM_LONS, NUM_CHAN), dtype='int16')
    daily_h5f_out = os.path.join(output_folder, 'vis_{}.h5'.format(iday))    
    
    
    
    
    # Generate input file list
    mod02_files = []
    mod03_files = []
    for iyr in range(2000, 2016):
        # check file existence
        mod02_file = '/u/sciteam/smzyz/scratch/data/MODIS/MOD02_VIS_daily/{0}/MOD021KM.A{0}{1}.006.h5'.format(iyr, str_iday)
        mod03_file = '/u/sciteam/smzyz/scratch/data/MODIS/MOD03_daily/{0}/MOD03.A{0}{1}.006.h5'.format(iyr, str_iday)
        
        if os.path.isfile(mod02_file) & os.path.isfile(mod03_file):  
            mod02_files.append(mod02_file)
            mod03_files.append(mod03_file)
    
    print ">> process daily climatology of {}, considering {} years' data.".format(str_iday, len(mod02_files))
    
    
    
    
    
    # Call main_daily function
    for mod02, mod03 in zip(mod02_files, mod03_files):
        rad_sum, num_sum, solar_sum = main_daily(mod02, mod03)
        daily_insolation_sum += solar_sum
        daily_radiance_sum += rad_sum
        daily_radiance_num += num_sum
    
    
    
    
   
    # Save output arrays
    save_data_hdf5(daily_h5f_out, '/radiance_sum', daily_radiance_sum)
    save_data_hdf5(daily_h5f_out, '/radiance_num', daily_radiance_num)
    save_data_hdf5(daily_h5f_out, '/insolation_sum', daily_insolation_sum)


    


def times_gen(itype):
    """
    Generate times for processing, itype could be 1 or 2.
    itype == 1: Generate iyr+iday for MPI processing;
    itype == 2: Generate ihr+imin for granule processing, which calls once at the very begining of the Main function.
    """
    times = []
    if itype == 1:
        for iday in range(1, 367):
            tmp = "{}{}".format(iyr, str(iday).zfill(3))
            times.append(tmp)
                
    elif itype == 2:
        for ihr in range(0, 24):
            for imin in range(0, 60, 5):
                tmp = "{}{}".format(str(ihr).zfill(2), str(imin).zfill(2))
                times.append(tmp)

    return np.array(times)




# Type of run
#      single_file    mpi_job
tst = [   True,       False]






# Single_file test -- checked on 2018.05.07.
# Turn on tqdm.
if (__name__ == '__main__') & (tst[0]):
    iday = 1
    output_folder = '/u/sciteam/smzyz/'
    main_daily_climatology(iday, output_folder)



    
    
# Batch_job test -- checked on 2018.05.07.
# Turn off tqdm.
if (__name__ == '__main__') & (tst[1]):
    NUM_CORES = int(sys.argv[1])
    
    import mpi4py.MPI as MPI
    comm = MPI.COMM_WORLD
    comm_rank = comm.Get_rank()
    
    output_folder = '/u/sciteam/smzyz/scratch/results/MODIS_ClimateMarble_005deg/daily/vis'
    
    for idd in range(1, 367, NUM_CORES):
        
        
        
        
        itime = times[idd+comm_rank]

        mod02_file = 'MOD021KM.A{}.006.h5'.format(itime)
        mod03_file = 'MOD03.A{}.006.h5'.format(itime)
        
        mod02_path = '/u/sciteam/smzyz/scratch/data/MODIS/MOD02_VIS_daily/{}/{}'.format(itime[:4], mod02_file)
        mod03_path = '/u/sciteam/smzyz/scratch/data/MODIS/MOD03_daily/{}/{}'.format(itime[:4], mod03_file)

        print ">> log: PE {} on {}".format(comm_rank, mod02_file)
        main_daily_climatology(mod02_path, mod03_path, output_folder)

