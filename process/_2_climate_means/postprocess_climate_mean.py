


# Functions here are used for processing daily mean radiances, which were generated by ../ClimateMarble_with_fortran.py.
# Those daily mean values (stored by category, year, and day) are further processed go get climatology daily mean, monthly mean, 
# and climatology monthly mean radiances.
# 
# Those climatology daily means can be further processed by ../_3_moving_avg to get moving averages.
#


from my_module import np, os, Dataset, h5py, sys, tqdm
from my_module.data.comm import save_data_hdf5





        
def daily2monthly_mean(icat, iyr, imon):
    """
    As described in the function name, this function is used to generate 
    """
    
    
    doy_normal = [1, 1, 32, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366]
    doy_leap = [1, 1, 32, 61, 92, 122, 153, 183, 214, 245, 275, 306, 336, 367]
    
    data_folder = "/u/sciteam/smzyz/scratch/results/MODIS_ClimateMarble_005deg/daily/{}/{}".format(icat, iyr)
    data_files = os.listdir(data_folder)
    output_dir = "/u/sciteam/smzyz/scratch/results/MODIS_ClimateMarble_005deg/monthly/"
    output_file = os.path.join(output_dir, "{}_{}_{}.h5".format(icat, iyr, str(imon).zfill(2)))
    
    
    if iyr in [2000, 2004, 2008, 2012]:
        doy = doy_leap
    else:
        doy = doy_normal
    
    
    print ">> work on {}.{}".format(iyr, imon)
    if icat in ['vis']:
        radiance_all = np.zeros((3600, 7200, 7))
        insolation_all = np.zeros((3600, 7200, 7))
        num_all = np.zeros((3600, 7200, 7))
    else:
        print ">> err: only supports visible bands right now."
        return
        
        
    doy_0 = doy[imon]
    doy_1 = doy[imon+1]
    
    
    for ifile in data_files:
        iday = int(ifile.split('.')[0][-3:]) # Example: ifile --> A2000265.h5
        
        if iday in range(doy_0, doy_1):
            ifile = os.path.join(data_folder, ifile)
            
            try:
                with h5py.File(ifile, 'r') as h5f:
                    solar = h5f['insolation_sum'][:]
                    rad = h5f['radiance_sum'][:]
                    num = h5f['radiance_num'][:]
                
                
                insolation_all = insolation_all + solar
                radiance_all = radiance_all + rad
                num_all = num_all + num
            except Exception as err:
                print ">> err: {}".format(err)
                continue

                
    mean_rad = np.array(radiance_all / num_all)
    mean_sol = np.array(insolation_all / num_all)
    
    save_data_hdf5(output_file, 'monthly_radiance', mean_rad)
    save_data_hdf5(output_file, 'monthly_insolation', mean_sol)
    save_data_hdf5(output_file, 'monthly_number', num_all)    
    
    
    
    
    
def climatology_daily_mean(icat, iday):
    """
    ---------
    Calculate climatology daily mean spectral radiances (& insolations) for the given category (icat), and calendar day (iday).  
    The output is in hdf5 format. Both vis and swir categories have climatoglogy_daily_radiance and climatoglogy_daily_insolation.
    LW category only has climatoglogy_daily_radiance.

    Updated: 2018.05.16
    ---------
    """
    
    str_iday = str(iday).zfill(3)


    # Initialize daily data folder and output file path
    working_dir = "/u/sciteam/smzyz/scratch/results/MODIS_ClimateMarble_005deg/daily/"
    output_file = "/u/sciteam/smzyz/scratch/results/MODIS_ClimateMarble_005deg/daily_mean/{}_{}.h5".format(icat, str_iday)


    # Initialize three temporal arrays used to store 16 years' daily data
    if icat in ['vis']:
        radiance_all = np.zeros((3600, 7200, 7))
        insolation_all = np.zeros((3600, 7200, 7))
        num_all = np.zeros((3600, 7200, 7))
    else:
        print ">> err: only supports visible bands right now."
        return


    # Iterates each year and collect available daily data of the specified category.
    for iyr in range(2000, 2016):
        ifile = "A{}{}.h5".format(iyr, str_iday)
        ifile_path = os.path.join(working_dir + "{}/{}".format(icat, iyr), ifile)
        
        try:
            h5f = h5py.File(ifile_path, 'r')
            insolation_all += h5f['insolation_sum'][:]
            radiance_all += h5f['radiance_sum'][:]
            num_all += h5f['radiance_num'][:]

        except Exception as err:
            print ">> err: {}".format(err)
            continue

    mean_rad = np.array(radiance_all / num_all)
    mean_sol = np.array(insolation_all / num_all)


    save_data_hdf5(output_file, 'climatoglogy_daily_radiance', mean_rad)
    save_data_hdf5(output_file, 'climatoglogy_daily_insolation', mean_sol)
    save_data_hdf5(output_file, 'climatoglogy_daily_number', num_all)




# def climatology_monthly_mean():
#     """
#     ---------
#     Calculate monthly mean spectral radiances (& insolations) for the given category (icat), and calendar day (iday).  
#     The output is in hdf5 format. Both vis and swir categories have monthly_radiance and monthly_insolation.
#     LW category only has monthly_radiance.

#     Updated: 2018.05.16
#     ---------
#     """
#     working_dir = "/u/sciteam/smzyz/scratch/results/MODIS_ClimateMarble_005deg/monthly/"
#     output_dir = "/u/sciteam/smzyz/"

#     output_file = os.path.join(output_dir, "{}_{}.npz".format(icat, str(iday).zfill(3)))


#     categories = ['SWIR_P1', 'SWIR_P2', 'LW_P1', 'LW_P2']
#     for icat in categories:
#         for imon in range(1, 13):
            
#             if icat in ['VIS', 'SWIR_P2']:
#                 rad_all = np.zeros((3600, 7200, 7))
#                 num_all = np.zeros((3600, 7200, 7))
#             else:
#                 rad_all = np.zeros((3600, 7200, 8))
#                 num_all = np.zeros((3600, 7200, 8))

#             for iyr in range(2000, 2016):
#                 ifile = "{}_{}_{}.npz".format(icat, iyr, imon)
#                 inpz = np.load(os.path.join(working_dir, ifile))
                
#                 rad_all += inpz['rad_all']
#                 num_all += inpz['num_all']
        
#             mean_rad = np.array(rad_all / num_all)
#             np.savez_compressed(os.path.join(output_dir, "{}_{}.npz".format(icat, imon)), mean_rad = mean_rad)



# def monthly_mean_rewrite_netCDF4(icat):
#     working_dir = "/u/sciteam/smzyz/"
#     output_dir = working_dir
    
#     if icat in ['VIS', 'SWIR_P2']:
#         tot_bands = 7
#     else:
#         tot_bands = 8
        
#     if icat == 'VIS':
#         channels = [1, 2, 3, 4, 5, 6, 7]
#     elif icat == 'SWIR_P1':
#         channels = [8,9,10,11,12,'13lo','13hi','14lo']
#     elif icat == 'SWIR_P2':
#         channels = ['14hi',15,16,17,18,19,26]
#     elif icat == 'LW_P1':
#         channels = [20,21,22,23,24,25,27,28]
#     elif icat == 'LW_P2':
#         channels = [29,30,31,32,33,34,35,36]
        
    
#     for iband in range(tot_bands):
#         print ">> Process band: {}".format(channels[iband])
#         data_out = []
#         for imon in range(1, 13):
#             ifile = "{}_{}.npz".format(icat, imon)
#             inpz = np.load(os.path.join(working_dir, ifile))
#             idata = inpz['mean_rad'][:, :, iband]
        
#             data_out.append(idata)
        
        
#         # Handle bad values and nan values
#         data_out = np.array(data_out)
#         data_out = np.nan_to_num(data_out)
#         np.place(data_out, data_out<=0, -999.)
        
        
#         # Start writing netCDF4 file
#         nc_file = Dataset(os.path.join(output_dir, "monthly_climate_band_{}.nc".format(channels[iband])), 'w')
#         print ">> Created variables with attributes"
#         # createDimension
#         dim_lat = nc_file.createDimension('lat', 3600)
#         dim_lon = nc_file.createDimension('lon', 7200)
#         dim_month = nc_file.createDimension('month', 12)
#         # createVariable
#         lat = nc_file.createVariable('lat', 'f4', ('lat',))
#         lat.units = 'degree'
#         lat.standard_name = 'latitude'
#         lon = nc_file.createVariable('lon', 'f4', ('lon',))
#         lon.units = 'degree'
#         lon.standard_name = 'longitude'
#         month = nc_file.createVariable('month', 'f4', ('month',))
#         month.standard_name = 'month'
#         data = nc_file.createVariable('mean_radiance', 'f4', ('month', 'lat', 'lon'), fill_value=-999.)
#         data.standard_name = 'Climatic monthly mean radiances (VZA<40 degree)'
#         data.units = 'W m-2 sr-1 um-1'


#         print ">> Writing data..."
#         lat[:] = np.arange(90, -90, -0.05) - 0.025
#         lon[:] = np.arange(-180, 180, 0.05) + 0.025
#         month[:] = np.arange(1, 13)
#         data[:] = data_out
#         nc_file.close()
      
        
        



if __name__ == '__main__':
    
    # 2018.06.06
    # modify script to receive up to 2 arguments, the first argument could be:
    # 0) test -- for single PE functional test
    # 1) clim_daily -- calculate climatology daily mean radiances from gridded daily mean radiances;
    # 2) monthly -- calculate monthly mean radiances from gridded daily mean radiances;
    # 3) clim_monthly -- calculate climatology monthly mean radiances from monthly mean radiances;
    #
    # the second argument is the number of PE used to process, if the first argument is test, this argument can be omitted. 

    
    if sys.argv[1] == 'test':
        # do some test jobs here
        
        climatology_daily_mean('vis', 1)


    elif sys.argv[1] in ['clim_daily', 'monthly', 'clim_monthly']:
        # do some batch jobs here

        NUM_CORES = int(sys.argv[2])
        
        import mpi4py.MPI as MPI
        comm = MPI.COMM_WORLD
        comm_rank = comm.Get_rank()
    
        if sys.argv[1] == 'clim_daily':
            for i in range(1, 367, NUM_CORES):
                iday = comm_rank + i
                
                print ">> PE: {}, working on day_{}.".format(comm_rank, iday)
                climatology_daily_mean('vis', iday)
        

        elif sys.argv[1] == 'monthly':
            times = []
            for iyr in range(2000, 2016):
                for imon in range(1, 13):
                    times.append("{}{}".format(iyr, str(imon).zfill(2)))

            for i in range(1, len(times), NUM_CORES):
                iyr_mon = comm_rank + i

                print ">> PE: {}, working on day_{}.".format(comm_rank, iyr_mon)
                daily2monthly_mean('vis', int(iyr_mon[:4]), int(iyr_mon[4:]))
        

        elif sys.argv[1] == 'clim_monthly':
            # for future purpose
            print ">> function has not implemented yet."



    else:
        print ">> {} is not a valid argument, please check it.".format(sys.argv[1])




